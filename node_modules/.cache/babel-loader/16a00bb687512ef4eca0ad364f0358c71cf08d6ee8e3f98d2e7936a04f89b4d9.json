{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor() {\n    let {\n      cacheName,\n      plugins = [],\n      fallbackToNetwork = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new PrecacheStrategy({\n      cacheName: cacheNames.getPrecacheName(cacheName),\n      plugins: [...plugins, new PrecacheCacheKeyPlugin({\n        precacheController: this\n      })],\n      fallbackToNetwork\n    });\n    // Bind the install and activate methods to the instance.\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n  get strategy() {\n    return this._strategy;\n  }\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n   */\n  precache(entries) {\n    this.addToCacheList(entries);\n    if (!this._installAndActiveListenersAdded) {\n      self.addEventListener('install', this.install);\n      self.addEventListener('activate', this.activate);\n      this._installAndActiveListenersAdded = true;\n    }\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n   *     Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n    const urlsToWarnAbout = [];\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n      this._urlsToCacheModes.set(url, cacheMode);\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.InstallResult>}\n   */\n  install(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const installReportPlugin = new PrecacheInstallReportPlugin();\n      this.strategy.plugins.push(installReportPlugin);\n      // Cache entries one at a time.\n      // See https://github.com/GoogleChrome/workbox/issues/2528\n      for (const [url, cacheKey] of this._urlsToCacheKeys) {\n        const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n        const cacheMode = this._urlsToCacheModes.get(url);\n        const request = new Request(url, {\n          integrity,\n          cache: cacheMode,\n          credentials: 'same-origin'\n        });\n        await Promise.all(this.strategy.handleAll({\n          params: {\n            cacheKey\n          },\n          request,\n          event\n        }));\n      }\n      const {\n        updatedURLs,\n        notUpdatedURLs\n      } = installReportPlugin;\n      if (process.env.NODE_ENV !== 'production') {\n        printInstallDetails(updatedURLs, notUpdatedURLs);\n      }\n      return {\n        updatedURLs,\n        notUpdatedURLs\n      };\n    });\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.CleanupResult>}\n   */\n  activate(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        printCleanupDetails(deletedURLs);\n      }\n      return {\n        deletedURLs\n      };\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * @param {string} url A cache key whose SRI you want to look up.\n   * @return {string} The subresource integrity associated with the cache key,\n   * or undefined if it's not set.\n   */\n  getIntegrityForCacheKey(cacheKey) {\n    return this._cacheKeysToIntegrities.get(cacheKey);\n  }\n  /**\n   * This acts as a drop-in replacement for\n   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (cacheKey) {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      return cache.match(cacheKey);\n    }\n    return undefined;\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @return {workbox-routing~handlerCallback}\n   */\n  createHandlerBoundToURL(url) {\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n    return options => {\n      options.request = new Request(url);\n      options.params = Object.assign({\n        cacheKey\n      }, options.params);\n      return this.strategy.handle(options);\n    };\n  }\n}\nexport { PrecacheController };","map":{"version":3,"names":["assert","cacheNames","logger","WorkboxError","waitUntil","createCacheKey","PrecacheInstallReportPlugin","PrecacheCacheKeyPlugin","printCleanupDetails","printInstallDetails","PrecacheStrategy","PrecacheController","constructor","cacheName","plugins","fallbackToNetwork","arguments","length","undefined","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","_strategy","getPrecacheName","precacheController","install","bind","activate","strategy","precache","entries","addToCacheList","_installAndActiveListenersAdded","self","addEventListener","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","warningMessage","join","console","warn","event","installReportPlugin","request","Request","cache","credentials","Promise","all","handleAll","params","updatedURLs","notUpdatedURLs","caches","open","currentlyCachedRequests","keys","expectedCacheKeys","Set","values","deletedURLs","delete","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","urlObject","URL","location","href","getIntegrityForCacheKey","matchPrecache","match","createHandlerBoundToURL","options","Object","assign","handle"],"sources":["C:/Users/ksury/OneDrive/Desktop/GIT/portfolio/node_modules/workbox-precaching/PrecacheController.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] The cache to use for precaching.\n     * @param {string} [options.plugins] Plugins to use when precaching as well\n     * as responding to fetch events for precached assets.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n            cacheName: cacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\n            ],\n            fallbackToNetwork,\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    /**\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n     * used to cache assets and respond to fetch events.\n     */\n    get strategy() {\n        return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener('install', this.install);\n            self.addEventListener('activate', this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n    install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            // Cache entries one at a time.\n            // See https://github.com/GoogleChrome/workbox/issues/2528\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: 'same-origin',\n                });\n                await Promise.all(this.strategy.handleAll({\n                    params: { cacheKey },\n                    request,\n                    event,\n                }));\n            }\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return { updatedURLs, notUpdatedURLs };\n        });\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n    activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedURLs = [];\n            for (const request of currentlyCachedRequests) {\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedURLs.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n            }\n            return { deletedURLs };\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return (options) => {\n            options.request = new Request(url);\n            options.params = Object.assign({ cacheKey }, options.params);\n            return this.strategy.handle(options);\n        };\n    }\n}\nexport { PrecacheController };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}